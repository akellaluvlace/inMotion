<div class="gallery">
	<ul class="cards">
		<li class="card">0</li>
		<li class="card">1</li>
		<li class="card">2</li>
		<li class="card">3</li>
		<li class="card">4</li>
		<li class="card">5</li>
		<li class="card">6</li>
		<li class="card">7</li>
		<li class="card">8</li>
		<li class="card">9</li>
		<li class="card">10</li>
		<li class="card">11</li>
		<li class="card">12</li>
		<li class="card">13</li>
		<li class="card">14</li>
		<li class="card">15</li>
		<li class="card">16</li>
		<li class="card">17</li>
		<li class="card">18</li>
		<li class="card">19</li>
		<li class="card">20</li>
		<li class="card">21</li>
		<li class="card">22</li>
		<li class="card">23</li>
		<li class="card">24</li>
		<li class="card">25</li>
		<li class="card">26</li>
		<li class="card">27</li>
		<li class="card">28</li>
		<li class="card">29</li>
		<li class="card">30</li>
	</ul>
	<div class="actions"><button class="prev">&#x25C0; Prev</button><button class="next">Next &#x25B6;</button></div>
</div><button class="refresh-btn" onclick="refreshCards()">Refresh Background</button>
<div class="instruction">
	<ul>Scroll the cards by<br />any of the following:<br /><br />
		<li>Action Buttons</li>
		<li>Mouse Wheel</li>
		<li>Up/Down Arrows</li>
		<li>Page-Up/Down</li>
	</ul>
</div>

<!--// PUG

.gallery
	ul.cards
		li.card 0
		li.card 1
		li.card 2
		li.card 3
		li.card 4
		li.card 5
		li.card 6
		li.card 7
		li.card 8
		li.card 9
		li.card 10
		li.card 11
		li.card 12
		li.card 13
		li.card 14
		li.card 15
		li.card 16
		li.card 17
		li.card 18
		li.card 19
		li.card 20
		li.card 21
		li.card 22
		li.card 23
		li.card 24
		li.card 25
		li.card 26
		li.card 27
		li.card 28
		li.card 29
		li.card 30
	.actions
		button.prev &#x25C0; Prev
		button.next Next &#x25B6;
button.refresh-btn(onclick="refreshCards()") Refresh Background
.instruction
	ul
		| Scroll the cards by
		br
		| any of the following:
		br
		br
		li Action Buttons
		li Mouse Wheel
		li Up/Down Arrows
		li Page-Up/Down

//-->

@import url("https://fonts.googleapis.com/css2?family=Roboto&family=Zen+Dots&display=swap");

* {
	box-sizing: border-box;
}

body {
	background: #222;
	min-height: 100vh;
	padding: 0;
	margin: 0;
	color: #fff;
	font-family: "Zen Dots", sans-serif;
	text-shadow: #000 1px 1px 5px, #000 -1px -1px 5px;
}

.gallery {
	position: absolute;
	width: 100%;
	height: 100vh;
	overflow: hidden;
}

.cards {
	position: absolute;
	width: 14rem;
	height: 18rem;
	top: 40%;
	left: 50%;
	transform: translate(-50%, -50%);
}

.cards li {
	list-style: none;
	padding: 0;
	margin: 0;
	width: 14rem;
	height: 18rem;
	text-align: center;
	line-height: 18rem;
	font-size: 2rem;
	border: 5px solid white;
	border-radius: 15px;
	position: absolute;
	top: 0;
	left: 0;
	background-size: cover;
	box-shadow: #000 1px 1px 5px, #000 -1px -1px 5px;
}

@for $i from 1 through 31 {
	.cards li:nth-of-type(#{$i}) {
		background-image: url(https://picsum.photos/800/600?random=#{$i});
	}
}

li:hover {
	color: #fff;
	transition: color 0.3s ease;
	box-shadow: rgba(255, 255, 255, 0.6) 0px 4px 15px,
		rgba(0, 0, 0, 0.3) 0px 4px 10px;
	z-index: 10; /* Brings the hovered card to the front */
}

.actions {
	position: absolute;
	bottom: 25px;
	left: 50%;
	transform: translateX(-50%);
}

button {
	display: inline-block;
	outline: none;
	border: none;
	padding: 8px 14px;
	background: #414141;
	background-image: -webkit-linear-gradient(top, #575757, #414141);
	background-image: -moz-linear-gradient(top, #575757, #414141);
	background-image: -ms-linear-gradient(top, #575757, #414141);
	background-image: -o-linear-gradient(top, #575757, #414141);
	background-image: linear-gradient(to bottom, #575757, #414141);
	text-shadow: #000 1px 1px 5px, #000 -1px -1px 5px;
	box-shadow: #000 1px 1px 5px, #000 -1px -1px 5px;
	color: #aaaaaa;
	text-decoration: none;
	margin: 0 auto 10px;
	border-radius: 4px;
	padding: 12px 25px;
	font-family: "Zen Dots", sans-serif;
	text-transform: uppercase;
	cursor: pointer;
	font-size: 10px;
	font-weight: 400;
	line-height: 18px;
	&:hover {
		background: #57a818;
		background-image: -webkit-linear-gradient(top, #57a818, #4d9916);
		background-image: -moz-linear-gradient(top, #57a818, #4d9916);
		background-image: -ms-linear-gradient(top, #57a818, #4d9916);
		background-image: -o-linear-gradient(top, #57a818, #4d9916);
		background-image: linear-gradient(to bottom, #57a818, #4d9916);
		text-shadow: 0px 1px 0px #32610e;
		box-shadow: 0px 1px 0px fefefe;
		color: #ffffff;
		text-decoration: none;
	}
}

.refresh-btn {
	position: fixed;
	top: 20px;
	right: 20px;
	padding: 10px 20px;
	background: #007bff;
	color: white;
	border: solid 2px black;
	border-radius: 5px;
	cursor: pointer;
	transition: background 0.3s ease;
	filter: drop-shadow(1px 2px 1px rgba(0, 0, 50, 0.7))
		drop-shadow(2px 4px 3px rgba(0, 0, 0, 0.5));
}

.refresh-btn:hover {
	background: #0056b3;
}

.instruction {
	position: fixed;
	top: 80px;
	right: 20px;
	padding: 10px 20px;
	font-size: 0.8rem;
}

/* Source: https://codepen.io/tommyho tommyho510@gmail.com */

/* Source: https://codepen.io/GreenSock/pen/qBqEZKg
 */

/* try moving the cards with screen buttons, mouse roller, keyboard page up or down, and keyboard up or down arrows  */

gsap.registerPlugin(ScrollTrigger);

let iteration = 0;
const spacing = 0.1,
	snap = gsap.utils.snap(spacing),
	cards = gsap.utils.toArray(".cards li"),
	seamlessLoop = buildSeamlessLoop(cards, spacing),
	scrub = gsap.to(seamlessLoop, {
		// we reuse this tween to smoothly scrub the playhead on the seamlessLoop
		totalTime: 0,
		duration: 0.5,
		ease: "power3",
		paused: true
	}),
	trigger = ScrollTrigger.create({
		start: 0,
		onUpdate(self) {
			if (self.progress === 1 && self.direction > 0 && !self.wrapping) {
				wrapForward(self);
			} else if (self.progress < 1e-5 && self.direction < 0 && !self.wrapping) {
				wrapBackward(self);
			} else {
				scrub.vars.totalTime = snap(
					(iteration + self.progress) * seamlessLoop.duration()
				);
				scrub.invalidate().restart(); // to improve performance, we just invalidate and restart the same tween. No need for overwrites or creating a new tween on each update.
				self.wrapping = false;
			}
		},
		end: "+=3000",
		pin: ".gallery"
	});

function wrapForward(trigger) {
	// when the ScrollTrigger reaches the end, loop back to the beginning seamlessly
	iteration++;
	trigger.wrapping = true;
	trigger.scroll(trigger.start + 1);
}

function wrapBackward(trigger) {
	// when the ScrollTrigger reaches the start again (in reverse), loop back to the end seamlessly
	iteration--;
	if (iteration < 0) {
		// to keep the playhead from stopping at the beginning, we jump ahead 10 iterations
		iteration = 9;
		seamlessLoop.totalTime(
			seamlessLoop.totalTime() + seamlessLoop.duration() * 10
		);
		scrub.pause(); // otherwise it may update the totalTime right before the trigger updates, making the starting value different than what we just set above.
	}
	trigger.wrapping = true;
	trigger.scroll(trigger.end - 1);
}

function scrubTo(totalTime) {
	// moves the scroll position to the place that corresponds to the totalTime value of the seamlessLoop, and wraps if necessary.
	let progress =
		(totalTime - seamlessLoop.duration() * iteration) / seamlessLoop.duration();
	if (progress > 1) {
		wrapForward(trigger);
	} else if (progress < 0) {
		wrapBackward(trigger);
	} else {
		trigger.scroll(trigger.start + progress * (trigger.end - trigger.start));
	}
}

document
	.querySelector(".next")
	.addEventListener("click", () => scrubTo(scrub.vars.totalTime + spacing));
document
	.querySelector(".prev")
	.addEventListener("click", () => scrubTo(scrub.vars.totalTime - spacing));

function buildSeamlessLoop(items, spacing) {
	let overlap = Math.ceil(1 / spacing), // number of EXTRA animations on either side of the start/end to accommodate the seamless looping
		startTime = items.length * spacing + 0.5, // the time on the rawSequence at which we'll start the seamless loop
		loopTime = (items.length + overlap) * spacing + 1, // the spot at the end where we loop back to the startTime
		rawSequence = gsap.timeline({ paused: true }), // this is where all the "real" animations live
		seamlessLoop = gsap.timeline({
			// this merely scrubs the playhead of the rawSequence so that it appears to seamlessly loop
			paused: true,
			repeat: -1, // to accommodate infinite scrolling/looping
			onRepeat() {
				// works around a super rare edge case bug that's fixed GSAP 3.6.1
				this._time === this._dur && (this._tTime += this._dur - 0.01);
			}
		}),
		l = items.length + overlap * 2,
		time = 0,
		i,
		index,
		item;

	// set initial state of items
	gsap.set(items, { xPercent: 300, opacity: 0, scale: 0 });

	// now loop through and create all the animations in a staggered fashion. Remember, we must create EXTRA animations at the end to accommodate the seamless looping.
	for (i = 0; i < l; i++) {
		index = i % items.length;
		item = items[index];
		time = i * spacing;
		rawSequence
			.fromTo(
				item,
				{ scale: 0, opacity: 0 },
				{
					scale: 1,
					opacity: 1,
					zIndex: 100,
					duration: 0.5,
					yoyo: true,
					repeat: 1,
					ease: "power1.in",
					immediateRender: false
				},
				time
			)
			.fromTo(
				item,
				{ xPercent: 300 },
				{ xPercent: -300, duration: 1, ease: "none", immediateRender: false },
				time
			);
		i <= items.length && seamlessLoop.add("label" + i, time); // we don't really need these, but if you wanted to jump to key spots using labels, here ya go.
	}

	// here's where we set up the scrubbing of the playhead to make it appear seamless.
	rawSequence.time(startTime);
	seamlessLoop
		.to(rawSequence, {
			time: loopTime,
			duration: loopTime - startTime,
			ease: "none"
		})
		.fromTo(
			rawSequence,
			{ time: overlap * spacing + 1 },
			{
				time: startTime,
				duration: startTime - (overlap * spacing + 1),
				immediateRender: false,
				ease: "none"
			}
		);
	return seamlessLoop;
}

function refreshCards() {
	const cards = document.querySelectorAll(".card");
	cards.forEach((card, index) => {
		card.style.animation = "none";
		card.style.background = `url('https://picsum.photos/800/600?random=${
			index + 1
		}&t=${Date.now()}') center/cover no-repeat`;
		card.offsetHeight; // Trigger reflow
		card.style.animation = null;
	});
}
